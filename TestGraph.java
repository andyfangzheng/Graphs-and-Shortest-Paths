import java.util.*;
import java.io.*;
/**
 * Kanghui Liu, Fangzheng Sun
 * 05/24/2015
 *
 * The test class is to test the correctness of the graph. In the class I create a new graph 
 * with 7 vertices named A, B, C, D, E, F, G. The cost of two positively adjacent characters, 
 * such as A to B (or B to A), is 1, regardless positive or negative. If there is a path 
 * not between adjacent characters, the cost will be 10 more times the distance. For 
 * instance, the cost between A to C (or C to A) will be 20. Thus, obviously the shortest
 * path between two characters will be the series of all characters between them, including 
 * the two characters. The two files are called alpha.txt and cost.txt. The codes are based 
 * on FindPaths.java, and the algorithm is basically the same except that after typing the 
 * character, there will be some testing code to compute whether the graph really gives the 
 * optimal solution.
 */
public class TestGraph {
	public static void main(String[] args) {
      args = new String[]{"alpha.txt", "cost.txt"};
		if(args.length != 2) {
			System.err.println("USAGE: java Paths <vertex_file> <edge_file>");
			System.exit(1);
		}
      
		MyGraph g = readGraph(args[0],args[1]);
      
      //label the function of the test
      System.out.println("This is aimed at testing whether the graph gives the optimal choice");
      System.out.println("To start a test, please choose any vertex in the table");
      
      //Try positive order, such as A to F or negative order, such as E to B, and the stable 
      //ones, such as C to C, and even try the characters not in the table. 
		Scanner console = new Scanner(System.in);
		Collection<Vertex> v = g.vertices();
                Collection<Edge> e = g.edges();
		System.out.println("Vertices are "+v);
		System.out.println("Edges are "+e);
		while(true) {
			System.out.print("Start vertex? ");
			Vertex a = new Vertex(console.nextLine());
			if(!v.contains(a)) {
				System.out.println("no such vertex");
				System.exit(0);
			}
			
			System.out.print("Destination vertex? ");
			Vertex b = new Vertex(console.nextLine());
			if(!v.contains(b)) {
				System.out.println("no such vertex");
				System.exit(1);
			}
         //this part prints out the path and cost
			Path path = g.shortestPath(a,b); //crete path from a to b
         String result = ""; //output the path
         if(path == null){
            System.out.println("no path");
         }else{
            System.out.println("The shortest path from " + a + " to " + b + " is:");
            //print out all labels in the path
            for(Vertex ve : path.vertices){
               result += ve.getLabel() + " "; //this String will be used in the test;
            }
            System.out.print(result);
            System.out.println();
            System.out.println("The cost is " + path.cost);//print out the cost
         }
         
         //Here is testing code. Based on the fact that fastest path from one character to 
         //another will exactly be the same as what appears between the two characters in the 
         //alphabetic table since gapping between characters will cost 10 times than usual. 
         //This algrithom provides us a method to compare the result generated by the graph
         //and the fact. For instance, from A to E, the best way is A-B-C-D-E, distance is 4.
         //E-D-C-B-A for E to A, cost will also be 4. 
         
         //get the distance between. the two characters.
         int distance = Math.abs((char)b.getLabel().charAt(0) - (char)a.getLabel().charAt(0));
         System.out.println("The exact distance is " + distance);
         String alphabeta = "";
         //two case: positive path or negative path.
         if((char)a.getLabel().charAt(0) > (char)b.getLabel().charAt(0)){
            for(char i = (char)a.getLabel().charAt(0); i >= (char)b.getLabel().charAt(0); i--){
               alphabeta += i + " ";
            }
         }else{
            for(char i = (char)a.getLabel().charAt(0); i <= (char)b.getLabel().charAt(0); i++){
               alphabeta += i + " ";
            }
         }
         System.out.println("The exact optimal path is");
         System.out.println(alphabeta);
         
         //compare between the smallest distance given by the graph and the exact distance
         //also compare the content in the path
         if(path.cost != distance || !result.equals(alphabeta)){
            System.out.println("the test fails");
         }else{
            System.out.println("Path test is successful!");
         }    
		}
	}
   
   
	public static MyGraph readGraph(String f1, String f2) {
		Scanner s = null;
		try {
			s = new Scanner(new File(f1));
		} catch(FileNotFoundException e1) {
			System.err.println("FILE NOT FOUND: "+f1);
			System.exit(2);
		}

		Collection<Vertex> v = new ArrayList<Vertex>();
		while(s.hasNext())
			v.add(new Vertex(s.next()));

		try {
			s = new Scanner(new File(f2));
		} catch(FileNotFoundException e1) {
			System.err.println("FILE NOT FOUND: "+f2);
			System.exit(2);
		}

		Collection<Edge> e = new ArrayList<Edge>();
		while(s.hasNext()) {
			try {
				Vertex a = new Vertex(s.next());
				Vertex b = new Vertex(s.next());
				int w = s.nextInt();
				e.add(new Edge(a,b,w));
			} catch (NoSuchElementException e2) {
				System.err.println("EDGE FILE FORMAT INCORRECT");
				System.exit(3);
			}
		}

		return new MyGraph(v,e);
	}
}

